---
inclusion: manual
---
# 通用面试准备规则

## 🎯 核心原则

### 1. 言简意赅，直击要害
- **拒绝长篇大论**：基础回答必须精简，只讲核心概念和最关键的机制。
- **留白艺术**：不要一次性把所有细节全说完，要学会留白，让面试官有追问的空间。
- **时长控制**：基础回答控制在 **45秒-1分钟** 以内。

### 2. 思路清晰，逻辑胜于细节
- **宏观优先**：先讲整体流程/架构，再讲具体细节。
- **结构化表达**：虽然要求口语化，但内核要有清晰的逻辑结构（如"正常流程 vs 异常流程"、"读操作 vs 写操作"）。
- **关键点突出**：清晰地告诉面试官重点在哪里，不要让关键信息淹没在废话中。

### 3. 姿态谦逊，不卑不亢
- **避免绝对化**：少用"肯定"、"绝对"、"必须"，多用"一般来说"、"通常情况下"、"我的理解是"。
- **承认局限**：遇到不确认的细节，坦诚表达"这块细节我记得不太清了，但我推测..."，而不是强行编造。
- **沟通而非说教**：把面试当成一次技术交流，而不是你在给面试官上课。

---

## 📂 文档生成与输出规范

### 1. 直接写入文件（重要）
- **禁止输出正文**：当接到生成面试文档的指令时，**严禁**在对话框中输出文档正文。
- **使用工具写入**：必须直接使用文件写入工具（如 `write`）将内容保存到指定路径。
- **仅回复路径**：操作完成后，仅需回复："已生成文档：`[文件路径]`"，无需其他废话。

### 2. 目录结构规范
- **根目录**：所有文档统一存放在 `面试/` 目录下。
- **子目录分类**：根据技术栈自动归类，例如：
  - `面试/java/`
  - `面试/mysql/`
  - `面试/redis/`
  - `面试/spring/`
  - `面试/kafka/`
  - `面试/分布式/`
- **文件命名**：使用清晰的问题描述作为文件名，如 `面试/redis/Redis的过期策略有哪些.md`。

---

## 🗣️ 口述稿内容表达规范

### 1. 代码与SQL的口语化转换
**严禁在口述稿中直接插入长段代码或 SQL 语句。必须将其转化为自然的中文描述。**

- **长代码处理**：
  - ❌ "这里执行 `for (int i=0; i<n; i++) { ... }`"
  - ✅ "这里我们会遍历整个列表，对每个元素执行..."
- **SQL 语句处理**：
  - ❌ "执行 `SELECT * FROM table WHERE status = 1 FOR UPDATE`"
  - ✅ "执行一个查询，筛选出状态为1的记录，并且加上排他锁..."
- **补充说明**：对于必须提到的关键类名或方法名，可以在括号中补充中文辅助说明。
  - 示例：`ConcurrentHashMap`（那个线程安全的哈希表）

### 2. 复杂术语的解释
**对于生僻或复杂的英文术语，不要直接甩词，要补充通俗解释或类比。**

- ❌ "触发 Rebalance 机制"
- ✅ "触发 Rebalance（重平衡）机制，也就是重新分配一下消费者的分区..."
- ❌ "使用 Zero Copy 技术"
- ✅ "使用 Zero Copy（零拷贝）技术，简单说就是减少数据在内核态和用户态之间的拷贝次数..."

### 3. 从原理实现角度阐述（⚠️ 重要）
**关键技术点的描述必须体现实现机制，而非单纯的比喻或抽象概念。这样更专业、更有说服力。**

- **数据结构层面**：说明底层用什么数据结构实现
  - ❌ "漏桶算法就像漏斗漏水一样..."（纯比喻）
  - ✅ "漏桶算法基于队列实现，请求进入队列，按照固定速率出队处理..."（体现实现）

- **处理流程层面**：说明具体的操作步骤和计算逻辑
  - ❌ "滑动窗口把时间拆成更小的时间段..."（笼统描述）
  - ✅ "滑动窗口把固定窗口拆成更小的时间段，比如 1s 内划分为10个100ms，随着时间推移，窗口滑动，新的 100ms 窗口纳入计算，旧的移除..."（具体化操作）

- **机制层面**：说明如何保证某种特性
  - ❌ "令牌桶允许突发流量..."（结果描述）
  - ✅ "令牌桶按固定速率生成令牌存入桶中，请求到达时尝试获取令牌，桶中有足够令牌时可立即处理，这样就允许了突发流量..."（因果机制）

**核心原则**：
- ✅ 描述"怎么做到的"（数据结构 + 处理逻辑）
- ❌ 只描述"是什么样的"（现象或比喻）
- ✅ 体现技术实现细节（如"划分为N个时间段"、"基于队列"、"固定速率出队"）
- ❌ 停留在概念层面（如"更平滑"、"匀速处理"）

**平衡点**：
- 基础回答中：可以先用1句简单比喻建立印象，但**必须紧接着补充实现机制**
- 追问部分：完全从原理实现角度展开，包括数据结构、算法步骤、状态维护等

---

## 🗣️ 口述稿结构模板

### 模板 A：概念/原理类问题
**适用**：事务特性、GC算法、索引结构等。

```markdown
## 口述稿

**[问]**：（问题）

【开场 - 谦逊且直接】
"关于这个问题，我是这么理解的..." 或 "在平时开发中，我主要关注这几个方面..."

【基础回答 - 建立框架 + 核心点】
**规则**：先说有几点，再逐个简述。每个点 1 句话概括。

"主要包含[核心概念A]、[核心概念B]和[核心概念C]。"

"首先是[核心概念A]，它主要是为了解决...问题。（简述作用）"

"然后是[核心概念B]，通常是通过...机制实现的。（简述原理，[关键词]埋坑）"

"最后是[核心概念C]..."

【总结 - 简短收尾】
"总的来说，这套机制保证了..."

---

【追问部分 - 深度细节】
**[追问1]**：如果面试官追问"[核心概念B]具体怎么实现的？"
（这里再展开讲底层细节、配置参数、源码逻辑等。**注意：涉及代码逻辑时请使用中文描述流程，不要直接读代码**）

### 底层原理代码（展示核心数据结构和处理逻辑）
（在文档末尾必须提供底层源码级别的解析，而非简单的 API 使用示例）

```java
// ✅ 展示底层数据结构
class HashMap<K,V> {
    Node<K,V>[] table;  // 核心数据结构：数组
    int threshold;      // 扩容阈值
    
    static class Node<K,V> {  // 链表节点结构
        final int hash;
        final K key;
        V value;
        Node<K,V> next;  // 体现链表冲突解决
    }
    
    // ✅ 展示核心处理逻辑
    final V putVal(int hash, K key, V value) {
        // 1. 计算下标
        int i = (n - 1) & hash;
        // 2. 处理冲突
        // 3. 扩容判断
        // ...
    }
}
```

### 数据时间线（可选 - 适用于复杂流程）
（如果流程复杂，提供一个时间线或状态流转图）
- T1: 事务开启
- T2: 写入 undo log
- ...
```

### 模板 B：方案/解决类问题
**适用**：如何解决并发、如何设计缓存、如何优化SQL等。

```markdown
## 口述稿

**[问]**：（问题）

【开场 - 模拟思考 + 谦逊】
"嗯...这个问题在实际场景中确实比较常见。我以前遇到类似情况时，主要考虑过这几个方向..."

【基础回答 - 呈现思路】
**规则**：重点展示**分析问题的过程**，而不是直接堆砌技术栈。

"首先，我会先分析瓶颈在哪里，是...还是...。"

"如果是...的情况，通常会采用[方案A]，利用它的...特性。（简述理由）"

"当然，也有可能是...的情况，这时候[方案B]可能更合适，虽然稍微复杂点，但能解决...问题。（体现权衡）"

【总结 - 开放式结尾】
"具体用哪种，可能还得看当时的业务体量和具体需求。"

---

【追问部分 - 深度细节】
**[追问1]**：如果面试官追问"[方案B]的具体实现细节"
（详细展开技术实现。**涉及 SQL 或配置时，用中文描述其意图，如"我们会加一个唯一索引来防止..."**）

### 底层原理代码（展示核心数据结构和处理逻辑）
（在文档末尾提供源码级别的原理解析）

```java
// ✅ 展示底层数据结构和核心逻辑
// 例如：线程池的核心处理
class ThreadPoolExecutor {
    // 核心数据结构
    private final BlockingQueue<Runnable> workQueue;  // 任务队列
    private final HashSet<Worker> workers;             // 工作线程集合
    
    // 核心处理逻辑
    public void execute(Runnable command) {
        if (workerCount < corePoolSize) {
            addWorker(command, true);  // 创建核心线程
        } else if (workQueue.offer(command)) {
            // 入队成功
        } else if (workerCount < maximumPoolSize) {
            addWorker(command, false);  // 创建非核心线程
        } else {
            reject(command);  // 拒绝策略
        }
    }
}
```

### 完整流程/时间线（可选）
- 步骤1: ...
- 步骤2: ...
```

---

## 💡 "思路清晰"的表达技巧

在回答时，通过以下方式体现逻辑性：

1.  **先总后分**
    - ✅ "Java 的内存区域主要分为线程私有和线程共享两大类。线程私有的包括...，线程共享的包括..."
    - ❌ "有堆、栈、方法区、本地方法栈、程序计数器..."（散乱无章）

2.  **流程化描述**
    - ✅ "当一个请求进来，首先会经过...，然后...，如果失败了会...，最后..."
    - ❌ "这里用到了A组件，那里用到了B组件，还有C组件..."（缺乏串联）

3.  **对比与权衡**（最能体现思路）
    - ✅ "虽然 A 方案性能更好，但考虑到我们的数据一致性要求很高，所以通常会倾向于 B 方案。"
    - ❌ "我们就用了 B 方案，因为 B 方案好。"

4.  **区分场景**
    - ✅ "如果是读多写少的场景，我会...；但如果是高并发写，可能需要..."

---

## 🛡️ "放低姿态"的语言模式

| ❌ 过于自信/生硬 | ✅ 谦逊/沟通式 |
| :--- | :--- |
| "这个必须用 volatile。" | "这种场景下，通常用 volatile 比较合适。" |
| "原理就是..." | "据我了解，它的底层原理主要是..." |
| "这点很简单，就是..." | "这一点比较基础，它是..." |
| "综上所述..." | "所以我个人觉得..." |
| "你不应该..." | "在实际操作中，我们可能尽量避免..." |
| (直接背诵定义) | "我的理解是，它其实就像..." (用通俗类比) |

---

## 🎣 引导与埋坑策略

**目的**：控制面试节奏，但要让面试官觉得是他在主导。

1.  **关键词埋坑**
    - 在基础回答中，提到一两个高阶概念（如"Zero Copy"、"MVCC"、"时间轮"），但**绝对不展开**。
    - *话术*："这里面可能会涉及到 [关键词] 的机制，通过它来提升性能。"（句号，停顿，等追问）

2.  **识别引导意图**
    - 如果用户在问题后标记 `引导点：XXX`，回答时要自然地把话题引向那个点。
    - *策略*：列举其他点时一笔带过，讲到引导点时稍微多说一句应用场景，然后停下。

---

## 📝 文档编写检查清单

写完一篇面试文档后，请自查：

- [ ] **字数检查**：基础回答部分是否足够精简？有没有废话？
- [ ] **逻辑检查**：是否体现了清晰的分析思路（总分、流程、对比）？
- [ ] **口语化检查**：**是否将代码/SQL/复杂术语转换为了中文自然描述？（禁止直接粘贴代码到口述稿中）**
- [ ] **结构检查**：是否严格遵守了"基础回答（简） + 追问（详）"的分离结构？
- [ ] **完整性检查**：**文档末尾是否包含了底层原理代码（数据结构+核心逻辑）？复杂场景是否补充了时间线/流程图？**
- [ ] **底层代码完整性检查（⚠️ 重要）**：
  - [ ] 是否展示了**核心数据结构**（如数组、链表、节点定义、关键字段）？
  - [ ] 是否展示了**核心处理逻辑**（如 put/get 的核心流程、线程创建判断）？
  - [ ] 代码是否覆盖了基础回答中的**所有核心点**（一个核心点都不能漏）？
  - [ ] 代码是否覆盖了追问部分的**深度概念**（如扩容机制、树化条件）？
  - [ ] **(禁止) 是否避免了纯 API 调用示例**（如 `map.put()`、`list.add()` 等演示代码）？
  - [ ] 代码注释是否标注了"这个字段/逻辑解决了什么问题"？
- [ ] **留白**：是否埋下了 1-2 个值得追问的关键词坑？

## 💻 底层原理代码与辅助材料规范

### 1. 代码重点：底层数据结构 + 核心处理逻辑（⚠️ 重要）

**代码的目的不是演示 API 使用，而是证明你读懂了源码和底层原理。**

- **必须展示的核心要素**：
  - ✅ **底层数据结构**：如 `Node[] table`、`BlockingQueue<Runnable> workQueue`、`HashSet<Worker> workers`
  - ✅ **核心处理逻辑**：如 `putVal()` 的冲突处理、线程池的 `execute()` 判断流程、`MVCC` 的版本链遍历
  - ✅ **关键字段/状态**：如 `threshold`、`loadFactor`、`workerCount`、`corePoolSize`
  
- **禁止的做法**：
  - ❌ 仅展示 API 调用：`Map<String, String> map = new HashMap<>(); map.put("k", "v");`
  - ❌ 纯业务演示代码：`UserService.login(username, password);`
  
- **注释要点明原理**：
  - 代码注释标明"这个数据结构解决了什么问题"、"这段逻辑体现了哪个核心机制"
  - 示例：`Node<K,V>[] table;  // 核心数据结构：数组，O(1) 查找`
  - 示例：`Node<K,V> next;  // 链表指针，解决哈希冲突`

### 2. 如何提取底层数据结构和核心逻辑（⚠️ 关键）

**从 JDK 源码或框架源码中提取关键部分，展示"数据如何存储"和"逻辑如何处理"。**

- **数据结构提取**（回答"数据怎么存"）：
  - 找到核心字段定义，如 `HashMap` 的 `Node<K,V>[] table`、`int threshold`
  - 找到节点/元素的结构，如 `static class Node<K,V>` 的字段定义
  - 体现存储结构的特点，如数组+链表、数组+红黑树、双向链表等

- **核心逻辑提取**（回答"怎么处理"）：
  - 找到关键方法的核心判断流程，如 `putVal()` 的冲突处理、`execute()` 的线程创建判断
  - 简化代码，只保留核心 if-else 判断和关键操作，去掉错误处理、日志等干扰代码
  - 用注释标注每一步的作用

- **示例（HashMap 源码提取）**：
  ```java
  // ===== JDK 源码：HashMap 的核心数据结构 =====
  class HashMap<K,V> {
      // 1. 底层数据结构
      Node<K,V>[] table;           // 数组，O(1) 定位
      int size;                     // 键值对数量
      int threshold;                // 扩容阈值 = capacity * loadFactor
      final float loadFactor;       // 负载因子，默认 0.75
      
      // 2. 节点结构
      static class Node<K,V> {
          final int hash;           // 缓存的 hash 值
          final K key;
          V value;
          Node<K,V> next;           // 链表指针，解决冲突
      }
      
      // 3. 核心处理逻辑
      final V putVal(int hash, K key, V value) {
          Node<K,V>[] tab;
          int i = (n - 1) & hash;                    // 计算下标（位运算优化）
          
          if ((p = tab[i]) == null)
              tab[i] = newNode(hash, key, value);   // 直接插入
          else {
              // 处理哈希冲突：链表或红黑树
              if (p.hash == hash && key.equals(p.key))
                  e = p;                             // key 相同，覆盖
              else if (p instanceof TreeNode)
                  e = putTreeVal(...);               // 红黑树插入
              else {
                  // 链表遍历
                  for (int binCount = 0; ; ++binCount) {
                      if ((e = p.next) == null) {
                          p.next = newNode(...);     // 尾插
                          if (binCount >= 7)
                              treeifyBin(tab, hash); // 链表转红黑树
                          break;
                      }
                      if (e.hash == hash && key.equals(e.key))
                          break;                     // 找到相同 key
                      p = e;
                  }
              }
          }
          
          if (++size > threshold)
              resize();                              // 扩容
          
          return oldValue;
      }
  }
  ```

### 3. 底层代码的组织结构

**按照"数据结构 → 核心逻辑 → 辅助机制"的顺序组织代码，清晰展示原理层次。**

- **第一层：核心数据结构**
  - 先展示存储结构（如数组、链表、节点定义）
  - 标注每个字段的作用和设计意图

- **第二层：核心处理逻辑**
  - 展示关键方法的核心流程（简化版，只保留主干逻辑）
  - 用注释标注每一步对应的原理

- **第三层：辅助机制**（可选）
  - 如有必要，展示扩容、树化、锁机制等辅助逻辑

```java
// ===== HashMap 源码原理展示 =====

// 【第一层：核心数据结构】
class HashMap<K,V> {
    Node<K,V>[] table;           // 数组：O(1) 定位
    int threshold;                // 扩容阈值
    
    static class Node<K,V> {     // 链表节点
        final int hash;
        final K key;
        V value;
        Node<K,V> next;           // 冲突解决
    }
}

// 【第二层：核心处理逻辑】
final V putVal(int hash, K key, V value) {
    int i = (n - 1) & hash;      // 1. 计算下标
    
    if (tab[i] == null)
        tab[i] = newNode(...);    // 2. 直接插入
    else
        // 链表/红黑树处理冲突    // 3. 冲突处理
    
    if (++size > threshold)
        resize();                 // 4. 扩容判断
}

// 【第三层：辅助机制】
final Node<K,V>[] resize() {
    // 扩容逻辑：容量翻倍，重新计算下标
}
```

### 4. 何时需要底层原理代码

**并非所有问题都需要大段代码，根据问题类型决定：**

| 问题类型 | 是否需要代码 | 展示重点 |
| :--- | :--- | :--- |
| 原理/源码类（HashMap原理、线程池工作流程） | ✅ **必须** | 数据结构 + 核心逻辑 |
| 概念类（什么是MVCC、什么是泛型） | ✅ **建议** | 简化的结构示意（如版本链节点定义） |
| 对比类（ArrayList vs LinkedList） | ⚠️ **可选** | 关键差异点的数据结构对比 |
| 方案类（如何解决并发问题） | ⚠️ **可选** | 如果涉及框架源码可展示，否则不必强求 |
| 纯应用类（如何配置、如何使用） | ❌ **不需要** | 配置说明 + 流程图即可 |

**核心判断标准**：
- ✅ 如果问题涉及"内部实现"、"底层原理"、"工作流程"，必须展示数据结构和核心逻辑
- ❌ 如果问题只关注"怎么用"、"怎么配置"，不需要代码

### 5. 数据时间线（Timeline）

- 对于涉及并发、状态流转、事务处理等复杂场景，**建议**补充一个"数据时间线"或"执行流程表"。
- 格式示例：
  ```text
  T1 (线程A): 读取余额 100
  T2 (线程B): 读取余额 100
  T3 (线程A): 更新余额 90 (CAS成功)
  T4 (线程B): 更新余额 80 (CAS失败, 重试)
  ```

### 6. 字节码/底层机制展示（可选）

- 对于涉及底层实现的问题（如类型擦除、指令重排、内存模型等），可以补充字节码或底层数据结构示意。
- 示例：展示类型擦除时，可以补充编译前后的字节码对比。
